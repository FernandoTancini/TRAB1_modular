*************************
 *
 *  $FC Fun‹o: LIS  -  Deturpar Lista
 *
 *************************/
#ifdef _DEBUG
LIS_tpCondRet LIS_DeturparLista (LIS_tppLista pLista, LIS_Deturpar acao)
{
    tpElemLista * pAuxiliar = NULL;
    tpElemLista *pAuxiliar2 = NULL;
    /*
     1 elimina o elemento corrente da lista.
     2 atribui NULL ao ponteiro para o pr—ximo n—.
     3 atribui NULL ao ponteiro para o n— anterior.
     4 atribui lixo ao ponteiro para o pr—ximo n—
     5 atribui lixo ao ponteiro o n— anterior.
     6 atribui NULL ao ponteiro para o conteœdo do n—.
     7 altera o tipo de estrutura apontado no n—.
     8 desencadeia n— sem liber‡-lo com free
     9 atribui NULL ao ponteiro corrente
     10 atribui NULL ao ponteiro de origem.*/

    if (pLista == NULL)
    {
        return LIS_CondRetListaVazia;
    }
    if (pLista->pElemCorr == NULL)
    {
        return LIS_CondRetElementoCorrenteIndefinido ;
    }  /* if */

    switch (acao)
    {
            //        case LIS_NaoDeturpa :
            //            break ;
        case LIS_EliminaElementoCorrente :
            free(pLista->pElemCorr) ;
            pLista->pElemCorr = NULL ;
            pLista->numElem = pLista->numElem - 1;
            break ;

        case LIS_NULLpNoProximoNo :
            pLista->pElemCorr->pProx = NULL ;
            break ;

        case LIS_NULLpNoAnt :
            pLista->pElemCorr->pAnt = NULL ;
            break ;

        case LIS_LixopNoProx :
            pLista->pElemCorr->pProx = (tpElemLista *) lixo ;
            break ;

        case LIS_LixopNoAnt :
            pLista->pElemCorr->pAnt = (tpElemLista *) lixo ;
            break ;

        case LIS_NULLpValorNo :
            pLista->pElemCorr->pValor = NULL ;
            break ;

        case LIS_AlteraTipoEstruturaNo :
            pLista->tipo;
            break ;

        case LIS_DesencadeiaNoSemFree :
            /* Se for o œnico da lista*/
            if (pLista->pElemCorr->pAnt == NULL && pLista->pElemCorr->pProx == NULL)
            {
                pLista->pElemCorr == NULL;
                pLista->pOrigemLista == NULL;
                pLista->pFimLista == NULL;
            }/* if */

            /se for o primeiro da lista/
            else if (pLista->pElemCorr->pAnt == NULL)
            {
                pAuxiliar = pLista->pElemCorr->pProx;
                pLista->pOrigemLista = pAuxiliar;
                pLista->pElemCorr = pAuxiliar;
            }/* else if */

            /* se for o œltimo elemento */
            else if (pLista->pElemCorr->pProx == NULL)
            {
                pAuxiliar = pLista->pElemCorr->pAnt;
                pAuxiliar->pProx = NULL;
                pLista->pFimLista = pAuxiliar;
                pLista->pElemCorr = pAuxiliar;
            } /* else if */
            /* se for no meio da lista */
            else {
                pAuxiliar = pLista->pElemCorr->pAnt;
                pAuxiliar2 = pLista->pElemCorr->pProx;

                pAuxiliar->pProx = pAuxiliar2;
                pAuxiliar2->pAnt = pAuxiliar;
                pLista->pElemCorr = pAuxiliar;
            }

            pLista->numElem-- ;
            break ;

        case LIS_NULLpCorrente :
            pLista->pElemCorr = NULL ;
            break ;

        case LIS_NULLpOrigem :
            pLista->pOrigemLista = NULL ;
            break ;

    } /* switch */
    return LIS_CondRetOK;
}
#endif
